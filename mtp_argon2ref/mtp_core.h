/*
 * MTPArgon2 reference source code package - reference C implementations
 *
 * Copyright 2015
 * Daniel Dinu, Dmitry Khovratovich, Jean-Philippe Aumasson, and Samuel Neves
 *
 * You may use this work under the terms of a Creative Commons CC0 1.0 
 * License/Waiver or the Apache Public License 2.0, at your option. The terms of
 * these licenses can be found at:
 *
 * - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
 * - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
 *
 * You should have received a copy of both of these licenses along with this
 * software. If not, they may be obtained at the above URLs.
 */

#ifndef MTP_ARGON2_CORE_H
#define MTP_ARGON2_CORE_H


#include "mtp_argon2ref/mtp_argon2.h"


#if defined(_MSC_VER)
#define ALIGN(n) __declspec(align(16))
#elif defined(__GNUC__) || defined(__clang)
#define ALIGN(x) __attribute__((__aligned__(x)))
#else
#define ALIGN(x)
#endif

#define CONST_CAST(x) (x)(uintptr_t)

/**********************MTPArgon2 internal constants*******************************/

enum mtp_argon2_core_constants {
    /* Memory argon_block size in bytes */
    MTP_ARGON2_argon_block_SIZE = 1024,
    MTP_ARGON2_QWORDS_IN_argon_block = MTP_ARGON2_argon_block_SIZE / 8,
    MTP_ARGON2_OWORDS_IN_argon_block = MTP_ARGON2_argon_block_SIZE / 16,

    /* Number of pseudo-random values generated by one call to Blake in MTPArgon2i
       to
       generate reference argon_block positions */
    MTP_ARGON2_ADDRESSES_IN_argon_block = 128,

    /* Pre-hashing digest length and its extension*/
    MTP_ARGON2_PREHASH_DIGEST_LENGTH = 64,
    MTP_ARGON2_PREHASH_SEED_LENGTH = 72
};

/*************************MTPArgon2 internal data types***********************/

/*
 * Structure for the (1KB) memory argon_block implemented as 128 64-bit words.
 * Memory argon_blocks can be copied, XORed. Internal words can be accessed by [] (no
 * bounds checking).
 */
/*
typedef struct argon_block_ { 
uint64_t v[MTP_ARGON2_QWORDS_IN_argon_block]; 
uint64_t prev_argon_block; 
uint64_t ref_argon_block;
} argon_block;
*/
/*****************Functions that work with the argon_block******************/

/* mtp_initialize each byte of the argon_block with @in */
void init_argon_block_value(argon_block *b, uint8_t in);

/* Copy argon_block @src to argon_block @dst */
void copy_argon_block(argon_block *dst, const argon_block *src);

/* XOR @src onto @dst bytewise */
void xor_argon_block(argon_block *dst, const argon_block *src);

/*
 * MTPArgon2 instance: memory pointer, number of passes, amount of memory, type,
 * and derived values.
 * Used to evaluate the number and location of argon_blocks to construct in each
 * thread
 */
/*
typedef struct MTPArgon2_instance_t {
    argon_block *memory;          // Memory pointer 
    uint32_t version;
    uint32_t passes;        // Number of passes 
    uint32_t memory_argon_blocks; // Number of argon_blocks in memory 
    uint32_t segment_length;
    uint32_t lane_length;
    uint32_t lanes;
    uint32_t threads;
    mtp_argon2_type type;
    int print_internals; // whether to print the memory argon_blocks 
    mtp_argon2_context *context_ptr; // points back to original context 
} mtp_argon2_instance_t;
*/
/*
 * MTPArgon2 position: where we construct the argon_block right now. Used to distribute
 * work between threads.
 */
typedef struct MTPArgon2_position_t {
    uint32_t pass;
    uint32_t lane;
    uint8_t slice;
    uint32_t index;
} mtp_argon2_position_t;

/*Struct that holds the inputs for thread handling FillSegment*/
typedef struct MTPArgon2_thread_data {
    mtp_argon2_instance_t *instance_ptr;
    mtp_argon2_position_t pos;
} mtp_argon2_thread_data;

/*************************MTPArgon2 core functions********************************/

/* Allocates memory to the given pointer, uses the appropriate allocator as
 * specified in the context. Total allocated memory is num*size.
 * @param context mtp_argon2_context which specifies the allocator
 * @param memory pointer to the pointer to the memory
 * @param size the size in bytes for each element to be allocated
 * @param num the number of elements to be allocated
 * @return MTP_ARGON2_OK if @memory is a valid pointer and memory is allocated
 */
int mtp_allocate_memory(const mtp_argon2_context *context, uint8_t **memory,
                    size_t num, size_t size);

/*
 * Frees memory at the given pointer, uses the appropriate deallocator as
 * specified in the context. Also cleans the memory using clear_internal_memory.
 * @param context mtp_argon2_context which specifies the deallocator
 * @param memory pointer to buffer to be freed
 * @param size the size in bytes for each element to be deallocated
 * @param num the number of elements to be deallocated
 */
void mtp_free_memory(const mtp_argon2_context *context, uint8_t *memory,
                 size_t num, size_t size);

/* Function that securely cleans the memory. This ignores any flags set
 * regarding clearing memory. Usually one just calls clear_internal_memory.
 * @param mem Pointer to the memory
 * @param s Memory size in bytes
 */
void mtp_secure_wipe_memory(void *v, size_t n);

/* Function that securely clears the memory if FLAG_clear_internal_memory is
 * set. If the flag isn't set, this function does nothing.
 * @param mem Pointer to the memory
 * @param s Memory size in bytes
 */
void mtp_clear_internal_memory(void *v, size_t n);

/*
 * Computes absolute position of reference argon_block in the lane following a skewed
 * distribution and using a pseudo-random value as input
 * @param instance Pointer to the current instance
 * @param position Pointer to the current position
 * @param pseudo_rand 32-bit pseudo-random value used to determine the position
 * @param same_lane Indicates if the argon_block will be taken from the current lane.
 * If so we can reference the current segment
 * @pre All pointers must be valid
 */
uint32_t mtp_index_alpha(const mtp_argon2_instance_t *instance,
                     const mtp_argon2_position_t *position, uint32_t pseudo_rand,
                     int same_lane);

/*
 * Function that validates all inputs against predefined restrictions and return
 * an error code
 * @param context Pointer to current MTPArgon2 context
 * @return MTP_ARGON2_OK if everything is all right, otherwise one of error codes
 * (all defined in <argon2.h>
 */
int mtp_validate_inputs(const mtp_argon2_context *context);

/*
 * Hashes all the inputs into @a argon_blockhash[PREHASH_DIGEST_LENGTH], clears
 * password and secret if needed
 * @param  context  Pointer to the MTPArgon2 internal structure containing memory
 * pointer, and parameters for time and space requirements.
 * @param  argon_blockhash Buffer for pre-hashing digest
 * @param  type MTPArgon2 type
 * @pre    @a argon_blockhash must have at least @a PREHASH_DIGEST_LENGTH bytes
 * allocated
 */
void mtp_initial_hash(uint8_t *argon_blockhash, mtp_argon2_context *context,
                  mtp_argon2_type type);

/*
 * Function creates first 2 argon_blocks per lane
 * @param instance Pointer to the current instance
 * @param argon_blockhash Pointer to the pre-hashing digest
 * @pre argon_blockhash must point to @a PREHASH_SEED_LENGTH allocated values
 */
void mtp_fill_first_argon_blocks(uint8_t *argon_blockhash, const mtp_argon2_instance_t *instance);

/*
 * Function allocates memory, hashes the inputs with Blake,  and creates first
 * two argon_blocks. Returns the pointer to the main memory with 2 argon_blocks per lane
 * mtp_initialized
 * @param  context  Pointer to the MTPArgon2 internal structure containing memory
 * pointer, and parameters for time and space requirements.
 * @param  instance Current MTPArgon2 instance
 * @return Zero if successful, -1 if memory failed to allocate. @context->state
 * will be modified if successful.
 */
int mtp_initialize(mtp_argon2_instance_t *instance, mtp_argon2_context *context);

/*
 * XORing the last argon_block of each lane, hashing it, making the tag. Deallocates
 * the memory.
 * @param context Pointer to current MTPArgon2 context (use only the out parameters
 * from it)
 * @param instance Pointer to current instance of MTPArgon2
 * @pre instance->state must point to necessary amount of memory
 * @pre context->out must point to outlen bytes of memory
 * @pre if context->free_cbk is not NULL, it should point to a function that
 * deallocates memory
 */
void mtp_finalize(const mtp_argon2_context *context, mtp_argon2_instance_t *instance);

/*
 * Function that fills the segment using previous segments also from other
 * threads
 * @param context current context
 * @param instance Pointer to the current instance
 * @param position Current position
 * @pre all argon_block pointers must be valid
 */
void mtp_fill_segment(const mtp_argon2_instance_t *instance,
                  mtp_argon2_position_t position);

/*
 * Function that fills the entire memory t_cost times based on the first two
 * argon_blocks in each lane
 * @param instance Pointer to the current instance
 * @return MTP_ARGON2_OK if successful, @context->state
 */
int mtp_fill_memory_argon_blocks(mtp_argon2_instance_t *instance);

int mtp_fill_memory_argon_blocks_mtp(mtp_argon2_instance_t *instance);
#endif
